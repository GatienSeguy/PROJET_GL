@startuml diagramme_sequence_entrainement
!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceMessageAlign center

title Diagramme de Séquence - Entraînement Complet avec Streaming

actor "Opérateur" as User
participant "UI\n(React)" as UI
participant "Store\n(Zustand)" as Store
participant "TrainingAPI" as TrainAPI
participant "Serveur IA\n(FastAPI)" as IA
participant "Trainer" as Engine
participant "Data\nPreprocessor" as Prep
participant "Model\nFactory" as Factory
participant "SSE\nStreamer" as SSE
participant "Serveur Data\n(REST API)" as Data

== Phase 1 : Configuration ==
User -> UI : Configure paramètres\n(modèle, hyperparamètres, etc.)
UI -> Store : Update config

== Phase 2 : Lancement Entraînement ==
User -> UI : Clique "Lancer"
UI -> Store : startTraining()
UI -> TrainAPI : startTraining(config)
TrainAPI -> IA : POST /train_full
activate IA

== Phase 3 : Récupération Dataset ==
IA -> Data : GET /datasets/{id}
activate Data
alt Succès
    Data -> Data : Charge dataset
    Data --> IA : TimeSeriesData\n(timestamps, values)
else Erreur (Fichier introuvable / Corrompu)
    Data --> IA : 404/500 Error
    IA -> SSE : Stream erreur
    SSE -> TrainAPI : data: {"type":"error", "msg":"..."}
    TrainAPI -> UI : onError()
    UI -> Store : stopTraining()
    deactivate Data
    destroy IA
end
deactivate Data

== Phase 4 : Préparation des Données ==
IA -> Prep : filter_series_by_dates()
activate Prep
Prep --> IA : timestamps_filtrés, values_filtrés
deactivate Prep

IA -> Prep : build_supervised_tensors()
activate Prep
Prep --> IA : X, y (tenseurs)
deactivate Prep

IA -> Prep : normalize_data()
activate Prep
Prep --> IA : X_norm, y_norm, params_norm
deactivate Prep

IA -> Prep : split_train_test()
activate Prep
Prep --> IA : X_train, y_train, X_test, y_test
deactivate Prep

IA -> SSE : Stream événement "split"
SSE -> TrainAPI : data: {"type":"info", "n_train":800, "n_test":200}
TrainAPI -> UI : onEvent(info)
UI -> UI : Affiche info split

== Phase 5 : Instanciation Modèle ==
IA -> Factory : create(model_type, config)
activate Factory
Factory -> Factory : Valide configuration
Factory -> Factory : Instancie MLP/CNN/LSTM
Factory --> IA : model (NeuralNet)
deactivate Factory

IA -> Engine : __init__(model, criterion, optimizer, device)
activate Engine

== Phase 6 : Entraînement avec Streaming ==
loop Pour chaque epoch (1 à nb_epochs)
    Engine -> Engine : Forward pass\ny_pred = model(X_train)
    Engine -> Engine : Calcul loss\nloss = criterion(y_pred, y_train)
    Engine -> Engine : Backward pass\nloss.backward()
    Engine -> Engine : Gradient clipping (si activé)
    Engine -> Engine : optimizer.step()
    Engine -> Engine : Calcul gradient_norm
    
    Engine --> IA : Événement epoch\n{"epoch", "loss", "gradient_norm"}
    IA -> SSE : format_sse(événement)
    SSE -> TrainAPI : data: {"type":"epoch", "loss":0.45}
    TrainAPI -> UI : onEvent(epoch)
    UI -> Store : addTrainingPoint()
    Store -> UI : Update TrainingChart
    
    alt Si bouton Annuler cliqué
        User -> UI : Clique "Arrêter"
        UI -> TrainAPI : stopTraining()
        TrainAPI -> IA : Interruption signal
        IA -> Engine : Stop training
        note right: Entraînement arrêté\nà la fin de l'epoch courante
    end
end

Engine --> IA : Modèle entraîné + historique
deactivate Engine

== Phase 7 : Test Automatique ==
IA -> IA : test_model(model, X_test, y_test, inverse_fn)
activate IA

loop Pour chaque échantillon de test
    IA -> IA : y_pred = model(X_test[i])
    IA -> IA : Dénormalisation\ninverse_fn(y_test[i]), inverse_fn(y_pred)
    IA -> SSE : Stream prédiction
    SSE -> TrainAPI : data: {"type":"pred_point", ...}
    TrainAPI -> UI : onEvent(pred_point)
end

IA -> IA : Calcul métriques finales\n(MSE, MAE, RMSE, MAPE, R²)
IA -> SSE : Stream métriques
SSE -> TrainAPI : data: {"type":"final_plot_data", ...}
TrainAPI -> UI : onComplete()
UI -> Store : setTestingData()
Store -> UI : Update TestingChart
deactivate IA

== Phase 8 : Prédiction future (Optionnel) ==
User -> UI : Définit horizon H
UI -> TrainAPI : predict(horizon=H)
TrainAPI -> IA : POST /predict
activate IA
IA -> Prep : Prépare entrée\n(dernières observations, fenêtres)
activate Prep
Prep --> IA : x_0, inverse_fn
deactivate Prep

loop Pour t = 1..H
    IA -> IA : y_pred_t = model(x_t)
    IA -> IA : Dénormalisation\ninverse_fn(y_pred_t)
    IA -> SSE : Stream prédiction future
    SSE -> TrainAPI : data: {"type":"forecast_step",...}
    IA -> IA : Met à jour x_{t+1}\n(roll/auto-régression)
end

IA --> TrainAPI : Série de prédictions
TrainAPI --> UI : Résultat
deactivate IA

== Phase 9 : Sauvegarde Automatique ==
IA -> IA : Prépare contexte complet\n(archi, params, metrics, history)
IA -> Data : POST /models\n(state_dict + context)
activate Data
Data -> Data : Génère UUID
Data -> Data : Sauvegarde fichier .pth
Data -> Data : Sauvegarde contexte JSON
Data --> IA : {"id": "uuid-1234", "created_at": "..."}
deactivate Data

IA -> SSE : Stream événement "complete"
SSE -> TrainAPI : data: {"type":"fin_pipeline"}
TrainAPI -> UI : onComplete()
deactivate IA

User -> UI : Consulte résultats

@enduml
